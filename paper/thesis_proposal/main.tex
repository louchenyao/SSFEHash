\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Thesis Proposal: Supersuper Fast and Efficient Hashing}
\author{Chenyao Lou}

\usepackage{natbib}
\usepackage{graphicx}
\usepackage{xspace}

\begin{document}

\maketitle

\newcommand{\qs}{\textit{Query Structure}\xspace}
\newcommand{\ms}{\textit{Maintenance Structure}\xspace}

\section{Introduction}

% The hash table is important: Speed, and space efficiency

The Hash table is a very crucial important component for systems. For example, the load balancer uses the hash table to decide the associated backend server for specified connections. Or it can store the Forwarding Information Base (FIB) for network applications [Dong, CuckooSwitch] like SDN. The lookup of FIB is the biggest bottleneck either for software packets forwarding or hardware packets forwarding. Thus, developers desire a high-performance hash table for such tasks.

Besides, the space efficiency is also an important metric for hash tables. It has two benefits. First, the small query structure can fit into the CPU cache, which is ten times faster than the main memory (DRAM). Thus the lookup performance an be accelerated further with the same hardware. Second, a space efficient hash table storing more items benefits memory-constrained tasks.

% variations of the hash table

Therefore, we propose a new space efficient hash table SSFE (Supersuper Fast Hashing) design with the high lookup performance. The basic functionality of a hash table is that, given a set of tuples $\{(k_0, v_0), (k_1, v_1), ..., (k_{n-1}, v_{n-1})\}$, the hash table can give $v_i$ for the question $q(k_i)$. There are variations of this definition: For a $k \not\in \{k_0, ..., k_{n-1}\}$, (1) the hash table returns $\bot$ (key is not existing), or (2) returns a random $v \in \mathcal{V}$. SSFE is designed for the second definition, i.e. it returns a random value when the query key has never been seen before.

% basic idea

SSFE consists of two structures, the \textit{Query Structure} and the \textit{Maintenance Structure}. The query structure has less memory footprint than the maintenance structure, and only serves for the lookup. It does not store any keys of tuples. That is why quering a non-existing key results in a random value. The maintenance structure is used to store all tuples so that it supports update operations. This seprating structures design fully utilize the CPU cache since the query structure stores more information by discarding keys. The system can update the query structure on a dedicated core without sacrificing the lookup performance.

% sections introduction

In section \ref{sec:design} we will disscuss the full design of SSFE, and engineering techniques. We compare SSFE with existing works in section \ref{sec:related_work}.

\section{Design}
\label{sec:design}

There are two main structures for SSFE, the \qs and the \ms. The \qs only serves for lookups.

\textbf{\qs} The tuples are partitioned into groups. SSFE uses a hash function to associate a key with a group. Each group contains $n$ tuples. In pratical, $n \le 300$. Physically, a group is an array $x$ with length $m$, the result of a query $q(k_i)$ is

$$v'_i = x[h_1(k_i)] \oplus x[h_2(k_i)] \oplus x[h_3(k_i)]$$

$h_1, h_2$ and $h_3$ are 3 different hash functions, the ranges are all $[0, m)$. Thus, the hard part is to find a value setting of $x$ satisfying $v'_i$ is equal to $v_i$ for all $i$.


\textbf{\ms} The maintenance structure explicitly maintains tuples of each group. It can naively use \texttt{std::vector} to maintain that since updates are not frequently. The \ms use these explicit information to construct $x$ for all groups.


\subsection{Construction}
\label{sec:construction}

WLOG, we only consider how to construct the $x$ for one group. Suppose there are $n$ tuples for this group, and the length of $x$ is $m$. The tuples are $\{(k_0, v_0), (k_1, v_1), ..., (k_{n-1}, v_{n-1})\}$. We construct a matrix $A_{n*m}$. Each row of $A$ represents a key. Initially, the $A$ is all zeros. For $k_i$, we increase $A_{i,h_1(k_i)}, A_{i,h_2(k_i)}$ and $A_{i,h_3(k_i)}$ with 1.

According the definition, we want $Ax = (v_0, v_1, ..., v_{n-1})^T = v$. Therefore, $x = A^{T}v$. Note that all addition operations are $xor$ operations in above steps.

The construction may fail. We do experiments shows that it needs $1.3$ times to find a feasible $A$ if the $A$ is randomly generated, when $m = 1.1n$. Thus, we can choose $h_1, h_2, h_3$ among a hash family. Then, the $A$ can be thought as a pesudo-random matrix. This needs SSFE to store the index of $h_1, h_2, h_3$.

\subsection{Group Size}

There are two alternative ways to decide the size of groups:

\begin{itemize}
    \item Fix the group size by a constant, e.g., 256. This makes the group are aligned to the cache line size. Also, the SSFE can compute the position of a group without readding any memory. A problem is that the associated tuples are not even among groups. The SSFE needs more groups to guarantee the group with most tuples has enough capacity. A workaround is to add a indcator to the group, to show whether it has enough space. If it is not, it follows a pointer to a dedicated memory area to extend the group. The cost per key is $1.3 size(value)$ bits.
    \item Decide the group size $m = 1.1n$, $n$ is the tuples associated to this group. The program needs a pointer array to index the position of each group, since sizes are varying. However, the group can be more compact, the cost per key is $1.1 size(value)$ bits.
\end{itemize}

\section{Related Work}
\label{sec:related_work}

\begin{table}[]
    \centering
    \begin{tabular}{lll}
        \hline
                  & Bits Per Key                     & False Postive \\ \hline\hline
    Cuckoo        & $1.05 (size(value) + size(key))$ & No            \\ \hline
    SepSet        & $2 + 2 size(value)$              & Yes           \\ \hline
    Othello       & $\le 4 size(value)$              & Yes           \\ \hline
    \textbf{SSFE} & $1.3 size(value)$  or $1.1 size(value)$ & Yes     
    \\ \hline
    \end{tabular}
    \caption{Comparsion between SSFE and existing hashing algorithms.}
    \label{tab:comparsion}
\end{table}

Table \ref{tab:comparsion} shows the comparsion among exiting hashings. It shows we archive the best space efficiency when the size of the value is relatively small.

\textbf{Cuckoo Hashing} Cuckoo has a fixed group size 4. Each key are mapped into two possible groups. So that, while one group is full, the tuple can store into the another group. The utilization rate can be $95\%$. It stores keys into the group. That prevents the false positive but increase the space overhead.

\textbf{SepSet} SepSet divides tuples into small groups. Each group contains 16 tuples in average. It uses $0.5$ bit per key to divide tuples more evenly. In each group, SepSet brute forcely find a hash function that can map all keys into the correct values. 

\textbf{Othello Hashing} Othello does not partition keys. It uses two array $a$ and $b$. The value of a query is $a[h_1(k_i)] \oplus b[h_2(k_i)]$. Othello abstracts those arrays as a bipartite graph, $(h_1(k_i), h_2(k_i))$ is a edge between two sides. When the bipartite group is acyclic, it can trivally set array values to find a feasible setting. They claim that it the probability of the group is acyclic is larger than $0.5$ when total bits are $4n$, so they only need to try $O(1)$ times to find a possile hash function.

\section{Plans}

\begin{itemize}
    \item Implement SSFE with two group allocation strategies.
    \item Compare the performance with different strategies.
    \item Investigate the fast and pratical way to accelerate the construction phase.
    \item Compare the performance with existing hashings.
\end{itemize}

\bibliographystyle{plain}
\bibliography{references}
\end{document}
